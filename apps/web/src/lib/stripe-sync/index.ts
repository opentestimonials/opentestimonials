import Stripe from 'stripe';
import invariant from 'tiny-invariant';
import { STRIPE_EVENT_TABLE_MAP } from './const/stripeEventTableMap';
import { StripeEventType } from './const/stripeEventTypes';
import { StripeTableName } from './const/stripeTableNames';
import { stripeTableProperties } from './const/stripeTableProperties';
import { logger } from './logger';
import { json } from './responses';
import type { StripeSyncDatabaseAdapter, SyncOptions } from './types';

function NotImplementedException() {
  throw new Error('Not implemented');
}

function isStripeEventType(type: any): type is StripeEventType {
  if (type in STRIPE_EVENT_TABLE_MAP) {
    return true;
  }
  return false;
}

function getTableName(event: Stripe.Event) {
  invariant(isStripeEventType(event.type), 'encountered invalid stripe event');
  const tableName = STRIPE_EVENT_TABLE_MAP[event.type];
  if (tableName === 'UNHANDLED') {
    throw new Error(`Unhandled stripe event type: ${event.type}`);
  }
  return tableName;
}

function isStripeTableName(type: any): type is StripeTableName {
  if (type in stripeTableProperties) {
    return true;
  }
  return false;
}

function getStripeTableProperties(tableName: string) {
  invariant(isStripeTableName(tableName), 'encountered invalid stripe table');
  return stripeTableProperties[tableName];
}

function isValidObjectId(
  obj: any
): obj is Stripe.Event.Data.Object & { id: string } {
  return !!obj.id;
}

export class StripeSync {
  private readonly stripe: Stripe;
  private readonly databaseAdapter: Required<StripeSyncDatabaseAdapter>;
  // private readonly _spec: StripeSpec

  constructor(props: {
    stripe: Stripe;
    databaseAdapter: StripeSyncDatabaseAdapter;
  }) {
    this.stripe = props.stripe;

    const databaseAdapter = {
      reservedSchema: 'stripe',
      useFakeSchema: false,
      maximumStaleCount: 10,
      ...props.databaseAdapter,
    };

    this.databaseAdapter = databaseAdapter;
  }

  async handleEvent(event: Stripe.Event) {
    const object = event.data.object;
    const table = getTableName(event);
    const schema = this.databaseAdapter.reservedSchema;
    const properties = getStripeTableProperties(table);
    const idempotencyKey = event.request?.idempotency_key;
    invariant(
      isValidObjectId(object),
      'encountered invalid stripe object (missing id)'
    );

    if (idempotencyKey) {
      const isEventAlreadyProcessed =
        await this.databaseAdapter.isEventAlreadyProcessed({
          schema: this.databaseAdapter.reservedSchema,
          idempotencyKey,
        });
      const data = {
        idempotency_key: idempotencyKey,
        event_id: event.id,
        object_id: object.id,
        created: event.created,
      };
      this.databaseAdapter.upsertRow({
        table: '_sync_events',
        schema: this.databaseAdapter.reservedSchema,
        data,
        properties: Object.keys(data),
        onConflictColumns: ['idempotency_key'],
      });
      if (isEventAlreadyProcessed) {
        logger.log(`Event already processed: ${idempotencyKey}`);
        // console.log(object);
        return;
      } else {
        // const data = {
        //   idempotency_key: idempotencyKey,
        //   event_id: event.id,
        //   object_id: object.id,
        //   created: event.created,
        // };
        // this.databaseAdapter.upsertRow({
        //   table: '_sync_events',
        //   schema: this.databaseAdapter.reservedSchema,
        //   data,
        //   properties: Object.keys(data),
        //   onConflictColumns: ['idempotency_key'],
        // });
      }
    }

    this.databaseAdapter.upsertRow({
      data: { ...object },
      table,
      schema,
      properties,
    });
  }

  async handleResyncEvents() {
    const mostRecentSyncCreated =
      await this.databaseAdapter.getMostRecentSyncCreated({
        schema: this.databaseAdapter.reservedSchema,
      });
    let events: Awaited<ReturnType<typeof this.stripe.events.list>>;
    // list returns in descending
    if (!mostRecentSyncCreated) {
      events = await this.stripe.events.list({
        limit: 100,
      });
    } else {
      events = await this.stripe.events.list({
        limit: 100,
        // starting_after: mostRecentSyncEventId,
        created: {
          gt: mostRecentSyncCreated,
        },
      });
    }
    if (events.data.length < 1) {
      return;
    }
    const mostRecentEvent = events.data[0];
    invariant(
      isValidObjectId(mostRecentEvent.data.object),
      'encountered invalid stripe object (missing id)'
    );

    const objectId = mostRecentEvent.data.object.id;

    const data = {
      idempotency_key: mostRecentEvent.request?.idempotency_key,
      event_id: mostRecentEvent.id,
      object_id: objectId,
      created: mostRecentEvent.created,
    };
    this.databaseAdapter.upsertRow({
      table: '_sync_events',
      schema: this.databaseAdapter.reservedSchema,
      data,
      properties: Object.keys(data),
      onConflictColumns: ['idempotency_key'],
    });

    for (const event of events.data) {
      this.handleEvent(event);
    }
  }

  syncEventsUntil(syncUntil: Date) {
    throw NotImplementedException();
  }
}

let syncClient: StripeSync;

export async function handleStripeWebhookEvent(
  request: Request,
  options: SyncOptions
) {
  if (!syncClient) {
    syncClient = new StripeSync({
      stripe: options.stripe,
      databaseAdapter: options.databaseAdapter,
    });
  }
  try {
    if (request.method !== 'POST') {
      throw new Error('Only POST requests are allowed');
    }

    const signature = request.headers.get('stripe-signature');
    if (!signature) {
      throw new Error('missing signature header');
    }
    let event: Stripe.Event;
    try {
      const body = await request.text();
      event = options.stripe.webhooks.constructEvent(
        body,
        signature,
        options.stripeEndpointSecret
      );
    } catch (err: any) {
      logger.log(`⚠️  Webhook signature verification failed.`, err.message);
      throw new Error('invalid signature');
    }
    logger.log(`Received triggered ${event.type}. (${event.id})`);
    await syncClient.handleEvent(event);

    return json('ok');
  } catch (e) {
    logger.error(e);
    throw new Response('server error', { status: 500 });
  }
}
