/**
 * Returns an (yesql formatted) upsert function based on the key/vals of an object.
 * eg,
 *  insert into customers ("id", "name")
 *  values (:id, :name)
 *  on conflict (id)
 *  do update set (
 *   "id" = :id,
 *   "name" = :name
 *  )
 */
export const constructUpsertPostgres = (
  schema: string,
  table: string,
  properties: string[],
  options?: {
    conflict?: string;
  }
): string => {
  const { conflict = 'id' } = options || {};

  return `
    insert into "${schema}"."${table}" (
      ${properties.map((x) => `"${x}"`).join(',')}
    )
    values (
      ${properties.map((x) => `:${x}`).join(',')}
    )
    on conflict (
      ${conflict}
    )
    do update set 
      ${properties.map((x) => `"${x}" = :${x}`).join(',')}
    ;`;
};

/**
 * Returns an (yesql formatted) upsert function based on the key/vals of an object.
 * eg,
 *  insert into customers ("id", "name")
 *  values (:id, :name)
 *  on conflict (id)
 *  do update set (
 *   "id" = :id,
 *   "name" = :name
 *  )
 */
export const constructUpsertMySql = (properties: string[]): string => {
  return `
      insert into ::__table (
        ${properties.map((x) => `${x}`).join(',')}
      )
      values (
        ${properties.map((x) => `:${x}`).join(',')}
      )
      on duplicate key update
        ${properties.map((x) => `${x} = :${x}`).join(',')}
      ;`;
};

// export const constructUpsertManyMySql = (properties: string[]): string => {
//   return `
//       insert into ::__table (
//         ${properties.map((x) => `${x}`).join(",")}
//       )
//       values (
//         ${properties.map((x) => `:${x}`).join(",")}
//       )
//       on duplicate key update
//         ${properties.map((x) => `${x} = :${x}`).join(",")}
//       ;`;
// };

/**
 * For array object field like invoice.custom_fields
 * ex: [{"name":"Project name","value":"Test Project"}]
 *
 * we need to stringify it first since passing array object directly will end up with
 * {
 * invalid input syntax for type json
 * detail: 'Expected ":", but found "}".',
 * where: 'JSON data, line 1: ...\\":\\"Project name\\",\\"value\\":\\"Test Project\\"}"}',
 * }
 */
export const cleanseArrayField = (obj: {
  [Key: string]: any;
}): {
  [Key: string]: any;
} => {
  const cleansed = { ...obj };
  for (const key in cleansed) {
    if (Array.isArray(cleansed[key])) {
      cleansed[key] = JSON.stringify(cleansed[key]);
    } else if (
      typeof cleansed[key] === 'object' &&
      !Array.isArray(cleansed[key]) &&
      cleansed[key] !== null &&
      !(cleansed[key] instanceof Date)
    ) {
      cleansed[key] = JSON.stringify(cleansed[key]);
    }
  }
  return cleansed;
};
