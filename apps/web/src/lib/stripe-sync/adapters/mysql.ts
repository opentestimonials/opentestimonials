// @ts-nocheck
import mysql, { RowDataPacket } from 'mysql2';
import { mysql as named } from 'yesql';
import { StripeSyncDatabaseAdapter } from '~/lib/stripe-sync/types';
import {
  cleanseArrayField,
  constructUpsertMySql,
} from '~/lib/stripe-sync/utils';
import env from '~/lib/utils/env.server';
import { logger } from '../logger';

const connection = mysql.createConnection(env.DATABASE_URL_MYSQL).promise();

interface MostRecentSyncCreated extends RowDataPacket {
  idempotency_key: string;
  event_id: string;
  object_id: string;
  created: Date;
}
interface IsEventAlreadyProcessed extends RowDataPacket {
  id: string;
}

export const mysqlAdapter: StripeSyncDatabaseAdapter = {
  async isEventAlreadyProcessed({ schema, idempotencyKey }) {
    const prepared = named(
      `select * from ::__table where idempotency_key = :idempotencyKey`
    )({
      __table: schema + '__sync_events',
      idempotencyKey,
    });
    const [rows] = await connection.query<IsEventAlreadyProcessed[]>(prepared);
    if (rows.length < 1) {
      return false;
    }
    if (rows.length === 1) {
      return true;
    }
    throw new Error('More than one row returned');
  },
  async getMostRecentSyncCreated({ schema }) {
    const prepared = named(
      `select created from ::__table order by created desc limit 1`
    )({
      __table: schema + '__sync_events',
    });
    const [rows] = await connection.query<MostRecentSyncCreated[]>(prepared);
    if (rows.length < 1) {
      return null;
    }
    if (rows.length === 1) {
      return Number(rows[0].created);
    }
    throw new Error('More than one row returned');
  },
  async upsertRow({ data, properties, schema, table }) {
    const fullTableName = `${schema}_${table}`;

    // Stripe sometimes sends weird stuff
    const nonNullData = Object.fromEntries(
      Object.entries(data).filter(([, value]) => value !== null)
    );

    // Create the SQL
    // const properties = getTableProperties(table); // Object.keys(nonNullData);
    const upsertString = constructUpsertMySql(properties);

    // Inject the values
    const cleansed = cleanseArrayField(nonNullData);
    const prepared = named(upsertString, { useNullForMissing: true })({
      ...cleansed,
      __table: fullTableName,
    });

    try {
      await connection.query(prepared.sql, prepared.values);
      // logger.log(
      //   `Upserted into \`${fullTableName}\` record with id.`
      // );
    } catch (e) {
      logger.error(e, data);
      console.error(e, data);
    }
  },
  async upsertRows({ rows, properties, schema, table }) {
    const fullTableName = `${schema}_${table}`;

    // Stripe sometimes sends weird stuff
    const nonNullData = Object.fromEntries(
      Object.entries(rows).filter(([, value]) => value !== null)
    );

    // Create the SQL
    // const properties = getTableProperties(table); // Object.keys(nonNullData);
    const upsertString = constructUpsertMySql(properties);

    // Inject the values
    const cleansed = cleanseArrayField(nonNullData);
    const prepared = named(upsertString, { useNullForMissing: true })({
      ...cleansed,
      __table: fullTableName,
    });

    try {
      await connection.query(prepared.sql, prepared.values);
      logger.log(
        `Upserted into \`${fullTableName}\` record ${rows.length} rows.`
      );
    } catch (e) {
      logger.error(e, rows);
      console.error(e, rows);
    }
  },
};
