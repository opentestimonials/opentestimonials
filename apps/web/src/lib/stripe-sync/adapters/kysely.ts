import { db } from '@/server/db/kysely';
import { logger } from '../logger';
import { StripeSyncDatabaseAdapter } from '../types';
import { cleanseArrayField } from '../utils';

export function filterObjectProperties<T extends Record<string, string>>(
  object: T,
  properties: (keyof T)[]
) {
  return Object.fromEntries(
    Object.entries(object).filter(([key]) => properties.includes(key))
  );
}

export const kyselyAdapter: StripeSyncDatabaseAdapter = {
  async isEventAlreadyProcessed({ schema, idempotencyKey }) {
    const rows = await db
      .selectFrom('stripe._sync_events')
      .selectAll()
      .where('idempotency_key', '=', idempotencyKey)
      .execute();
    console.log(rows);
    if (rows.length < 1) {
      return false;
    }
    if (rows.length === 1) {
      return true;
    }
    throw new Error('More than one row returned');
  },
  async getMostRecentSyncCreated({ schema }) {
    const rows = await db
      .selectFrom('stripe._sync_events')
      .orderBy('created', 'desc')
      .select(['created'])
      .limit(1)
      .execute();
    if (rows.length < 1) {
      return null;
    }
    if (rows.length === 1) {
      return Number(rows[0].created);
    }
    throw new Error('More than one row returned');
  },
  async upsertRow({ data, properties, schema, table, onConflictColumns }) {
    const fullTableName = `${schema}.${table}`;

    // Stripe sometimes sends weird stuff
    const nonNullData = Object.fromEntries(
      Object.entries(data).filter(
        ([key, value]) => value !== null && properties.includes(key)
      )
    );
    const cleansed = cleanseArrayField(nonNullData);

    try {
      await db
        .insertInto(fullTableName as any)
        .values(cleansed)
        .onConflict((oc) =>
          oc.columns(onConflictColumns ?? ['id']).doUpdateSet(cleansed)
        )
        .execute();
    } catch (e) {
      logger.error(e, data);
      console.error(e, data);
    }
  },
  async upsertRows({ rows, properties, schema, table, onConflictColumns }) {
    const fullTableName = `${schema}.${table}`;
    const nonNullData = rows.map((row) =>
      Object.fromEntries(
        Object.entries(row).filter(
          ([key, value]) => value !== null && properties.includes(key)
        )
      )
    );
    const cleansed = cleanseArrayField(nonNullData);

    try {
      await db
        .insertInto(fullTableName as any)
        .values(cleansed)
        .onConflict((oc) =>
          oc.columns(onConflictColumns ?? ['id']).doUpdateSet(cleansed)
        )
        .execute();
    } catch (e) {
      logger.error(e, rows);
      console.error(e, rows);
    }
  },
};
