import { handleStripeWebhookEvent } from '@/lib/stripe-sync';
import { kyselyAdapter } from '@/lib/stripe-sync/adapters/kysely';
import { env } from '@/server/env';
import { stripe } from '@/utils/stripe';
import { NextApiRequest, NextApiResponse } from 'next';
import getRawBody from 'raw-body';
import Cors from 'cors';

export function nextToWebHeaders(
  requestHeaders: NextApiRequest['headers']
): Headers {
  let headers = new Headers();

  for (let [key, values] of Object.entries(requestHeaders)) {
    if (values) {
      if (Array.isArray(values)) {
        for (let value of values) {
          headers.append(key, value);
        }
      } else {
        headers.set(key, values);
      }
    }
  }

  return headers;
}

async function nextRequestToWebRequest(req: NextApiRequest) {
  const protocol = req.headers.referer?.split('://')[0] ?? 'https';
  if (!protocol) {
    throw new Error('invalid protocol');
  }
  if (!req.url) {
    throw new Error('invalid url');
  }
  let origin = `${protocol}://${req.headers.host}`;
  let url = new URL(req.url, origin);

  let controller = new AbortController();

  req.on('close', () => {
    controller.abort();
  });

  if (!req.method) {
    throw new Error('invalid method');
  }
  let init: RequestInit = {
    method: req.method,
    headers: nextToWebHeaders(req.headers),
    signal: controller.signal,
  };

  if (req.method !== 'GET' && req.method !== 'HEAD') {
    const rawBody = await getRawBody(req);
    init.body = rawBody;
  }

  return new Request(url.href, init);
}

function sendWebResponse(options: {
  nextResponse: NextApiResponse;
  webResponse: Response;
}) {
  const { nextResponse, webResponse } = options;
  nextResponse.status(webResponse.status);
  for (let [key, values] of Object.entries(webResponse.headers)) {
    if (values) {
      if (Array.isArray(values)) {
        for (let value of values) {
          nextResponse.setHeader(key, value);
        }
      } else {
        nextResponse.setHeader(key, values);
      }
    }
  }
  nextResponse.send(webResponse.body);
}

export const config = {
  api: {
    bodyParser: false,
  },
};

// const cors = Cors({
//   allowMethods: ['POST', 'HEAD'],
// });

// export default cors(handler as any);
const cors = Cors({
  methods: ['POST', 'HEAD'],
});

// Helper method to wait for a middleware to execute before continuing
// And to throw an error when an error happens in a middleware
function runMiddleware(
  req: NextApiRequest,
  res: NextApiResponse,
  fn: Function
) {
  return new Promise((resolve, reject) => {
    fn(req, res, (result: any) => {
      if (result instanceof Error) {
        return reject(result);
      }

      return resolve(result);
    });
  });
}

export default async function StripeSync(
  req: NextApiRequest,
  res: NextApiResponse
) {
  await runMiddleware(req, res, cors);

  const webRequest = await nextRequestToWebRequest(req);
  const webResponse = await handleStripeWebhookEvent(webRequest, {
    stripeSecretKey: env.STRIPE_SECRET_KEY,
    stripe: stripe,
    stripeEndpointSecret: env.STRIPE_ENDPOINT_SECRET,
    databaseAdapter: kyselyAdapter,
  });
  return sendWebResponse({
    nextResponse: res,
    webResponse: webResponse,
  });
}

// export default async function handler(
//   req: NextApiRequest,
//   res: NextApiResponse
// ) {
//   // Run the middleware
//   await runMiddleware(req, res, cors)

//   // Rest of the API logic
//   res.json({ message: 'Hello Everyone!' })
// }
