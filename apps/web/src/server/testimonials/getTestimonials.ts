import { prisma } from '@/server/db/client';
import { filterValidTestimonials, Testimonial } from '@/validators/testimonial';
import { TRPCError } from '@trpc/server';
import Airtable from 'airtable';
import { z } from 'zod';

export interface TestimonialsAdapter {
  getTestimonials: (options: EmbedOptions) => Promise<Testimonial[]>;
}

export const AirtableAdapter: TestimonialsAdapter = {
  getTestimonials: async (options: EmbedOptions) => {
    const collection = await prisma.collection.findUnique({
      where: {
        subdomain: options.subdomain,
      },
    });
    if (!collection) {
      throw new TRPCError({ code: 'NOT_FOUND' });
    }
    const { airtableApiKey, airtableBase, airtableTable } = collection;
    if (!airtableApiKey || !airtableBase || !airtableTable) {
      console.error('Missing Airtable API key, base, or table');
      throw new TRPCError({ code: 'NOT_FOUND' });
    }
    const base = new Airtable({ apiKey: airtableApiKey }).base(airtableBase);
    const rawRecords = (
      await base(airtableTable)
        .select({
          maxRecords: 100,
          view: 'Grid view',
          cellFormat: 'json',
        })
        .all()
    ).map((r) => r._rawJson);

    return filterValidTestimonials(rawRecords).map((t) => ({
      id: t.id,
      created_at: t.createdTime,
      name: t.fields['Name'],
      quote: t.fields['Quote'],
      source_url: t.fields['Source URL'],
      company_url: t.fields['Company URL'],
      video_url: t.fields['Video URL'],
      images: t.fields['Images'],
      profile_url: t.fields['Profile URL'],
      profile_picture_url: t.fields['Profile Picture']?.[0]?.url,
      verified: t.fields['Verified'],
      title_or_company: t.fields['Title / Company'],
    }));
  },
};

export async function getTestimonials(
  adapter: TestimonialsAdapter,
  options: EmbedOptions
) {
  return adapter.getTestimonials(options);
}

export type TestimonialsResponse = Awaited<ReturnType<typeof getTestimonials>>;

export const embedRouterValidator = z.object({
  subdomain: z.string(),
  pathname: z.string().optional(),
});
export type EmbedOptions = z.infer<typeof embedRouterValidator>;
