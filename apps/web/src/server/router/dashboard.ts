import { env } from '@/env.mjs';
import { RESERVED_WORDS } from '@/lib/const';
import { prisma } from '@/server/db/client';
import { stripe } from '@/utils/stripe';
import { CreateCheckoutSessionValidator } from '@/validators/checkoutSession';
import {
  CreateCollectionValidator,
  getAirtableParts,
} from '@/validators/collection';
import { TRPCError } from '@trpc/server';
import Stripe from 'stripe';
import invariant from 'tiny-invariant';
import { z } from 'zod';
import { db } from '../db/kysely';
import { createRouter } from './context';
import { protectedProcedure, router } from './trpc';

function isReservedSubdomain(subdomain: string) {
  return RESERVED_WORDS.has(subdomain.toLowerCase());
}

export const legacyDashboardRouter = createRouter()
  .middleware(async ({ ctx, next }) => {
    // Any queries or mutations after this middleware will
    // raise an error unless there is a current session
    if (!ctx.session) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }
    return next();
  })
  .query('getSecretMessage', {
    async resolve({ ctx }) {
      return 'You are logged in and can see this secret message!';
    },
  })
  .query('collections', {
    async resolve({ ctx }) {
      return prisma.collection.findMany({
        where: {
          ownerId: ctx.session?.user?.id,
        },
      });
    },
  })
  .query('collection', {
    input: z.object({
      subdomain: z.string(),
    }),
    async resolve({ ctx, input }) {
      const collection = await prisma.collection.findUnique({
        where: {
          subdomain: input.subdomain,
        },
      });
      if (collection?.ownerId !== ctx.session?.user?.id) {
        throw new TRPCError({ code: 'UNAUTHORIZED' });
      }
      return collection;
    },
  })
  .query('checkoutSession', {
    input: z.object({
      checkoutSessionId: z.string(),
    }),
    async resolve({ input, ctx }) {
      const checkoutSession = await db
        .selectFrom('stripe.checkout_session')
        .selectAll()
        .where('id', '=', input.checkoutSessionId)
        .executeTakeFirst();

      if (
        !checkoutSession ||
        checkoutSession.customer_email !== ctx.session?.user?.email
      ) {
        throw new TRPCError({ code: 'UNAUTHORIZED' });
      }

      return checkoutSession;
    },
  })
  .query('hasLifetimePlan', {
    async resolve({ ctx }) {
      invariant(ctx.session?.user?.email, 'No user email');
      const charge = await db
        .selectFrom('stripe.customer')
        .innerJoin(
          'stripe.charge',
          'stripe.customer.id',
          'stripe.charge.customer'
        )
        .selectAll()
        .where('stripe.customer.email', '=', ctx.session?.user?.email)
        .executeTakeFirst();

      if (!charge) {
        return false;
      }
      return charge.status === 'succeeded';
    },
  })
  .query('subscription', {
    async resolve({ ctx }) {
      invariant(ctx.session?.user?.email, 'no user email');
      const subscription = await db
        .selectFrom('stripe.customer')
        .innerJoin(
          'stripe.subscription',
          'stripe.customer.id',
          'stripe.subscription.customer'
        )
        .selectAll()
        .where('stripe.customer.email', '=', ctx.session?.user?.email)
        .executeTakeFirst();

      return subscription;
    },
  })
  .mutation('collection', {
    input: CreateCollectionValidator,
    async resolve({ input }) {
      if (isReservedSubdomain(input.subdomain)) {
        throw new TRPCError({ code: 'FORBIDDEN' });
      }
      const { baseId, tableId } = getAirtableParts(input.airtableUrl);
      return prisma.collection.create({
        data: { ...input, airtableBase: baseId, airtableTable: tableId },
      });
    },
  })
  .mutation('isSubdomainValid', {
    input: z.object({ subdomain: z.string().min(1) }),
    async resolve({ input }) {
      if (isReservedSubdomain(input.subdomain)) {
        return { valid: false };
      }
      const collection = await prisma.collection.findUnique({
        where: {
          subdomain: input.subdomain,
        },
      });
      return { valid: !collection };
    },
  })
  .mutation('createCheckoutSession', {
    input: CreateCheckoutSessionValidator,
    async resolve({ input, ctx }) {
      invariant(ctx.session?.user?.email, 'missing user email');
      if (input.planName === 'lifetime') {
        const session = await stripe.checkout.sessions.create({
          line_items: [
            {
              price_data: {
                currency: 'usd',
                unit_amount: 150 * 100,
                product_data: {
                  name: 'Early Supporter',
                  description:
                    'Lifetime early supporter personal plan. Includes unlimited testimonials on unlimited websites, and personal support.',
                },
              },
              quantity: 1,
            },
          ],
          mode: 'payment',
          success_url:
            // env.SERVER_URL +
            `https://opentestimonials.com/dashboard/subscribed?session_id={CHECKOUT_SESSION_ID}`,
          //env.SERVER_URL +
          cancel_url: 'https://opentestimonials.com/dashboard/billing',
          customer_email: ctx.session?.user?.email,
        });
        invariant(session.url, 'missing session url');
        return { url: session.url };
      }
      const STRIPE_PRICE_DATA: Record<
        string,
        Stripe.Checkout.SessionCreateParams.LineItem.PriceData
      > = {
        personal: {
          currency: 'usd',
          unit_amount: 15 * 100,
          recurring: {
            interval: 'month',
          },
          product_data: {
            name: 'Starter',
            description: 'For small / medium sized businesses.',
          },
        },
        teams: {
          currency: 'usd',
          unit_amount: 299 * 100,
          recurring: {
            interval: 'month',
          },
          product_data: {
            name: 'Teams',
            description: 'For small / medium sized businesses.',
          },
        },
      };
      const session = await stripe.checkout.sessions.create({
        line_items: [
          {
            price_data: STRIPE_PRICE_DATA[input.planName],
            quantity: 1,
          },
        ],
        mode: 'subscription',
        success_url:
          env.SERVER_URL +
          `/dashboard/subscribed?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: env.SERVER_URL + '/dashboard/billing',
        customer_email: ctx.session?.user?.email,
      });
      invariant(session.url, 'missing session url');
      return { url: session.url };
    },
  });

export const dashboardRouter = router({
  getSecretMessage: protectedProcedure.query(() => {
    return 'You are logged in and can see this secret message!';
  }),
  collections: protectedProcedure.query(async ({ ctx }) => {
    return prisma.collection.findMany({
      where: {
        ownerId: ctx.session?.user?.id,
      },
    });
  }),
  collection: protectedProcedure
    .input(
      z.object({
        subdomain: z.string(),
      })
    )
    .query(async ({ ctx, input }) => {
      const collection = await prisma.collection.findUnique({
        where: {
          subdomain: input.subdomain,
        },
      });
      if (collection?.ownerId !== ctx.session?.user?.id) {
        throw new TRPCError({ code: 'UNAUTHORIZED' });
      }
      return collection;
    }),
  createCollection: protectedProcedure
    .input(CreateCollectionValidator)
    .mutation(async ({ ctx, input }) => {
      if (isReservedSubdomain(input.subdomain)) {
        throw new TRPCError({ code: 'FORBIDDEN' });
      }
      const { baseId, tableId } = getAirtableParts(input.airtableUrl);
      return prisma.collection.create({
        data: { ...input, airtableBase: baseId, airtableTable: tableId },
      });
    }),
  checkoutSession: protectedProcedure
    .input(
      z.object({
        checkoutSessionId: z.string(),
      })
    )
    .query(async ({ ctx, input }) => {
      const checkoutSession = await db
        .selectFrom('stripe.checkout_session')
        .selectAll()
        .where('id', '=', input.checkoutSessionId)
        .executeTakeFirst();

      if (
        !checkoutSession ||
        checkoutSession.customer_email !== ctx.session?.user?.email
      ) {
        throw new TRPCError({ code: 'UNAUTHORIZED' });
      }

      return checkoutSession;
    }),
  hasLifetimePlan: protectedProcedure.query(async ({ ctx }) => {
    invariant(ctx.session?.user?.email, 'No user email');
    const charge = await db
      .selectFrom('stripe.customer')
      .innerJoin(
        'stripe.charge',
        'stripe.customer.id',
        'stripe.charge.customer'
      )
      .selectAll()
      .where('stripe.customer.email', '=', ctx.session?.user?.email)
      .executeTakeFirst();

    if (!charge) {
      return false;
    }
    return charge.status === 'succeeded';
  }),
  subscription: protectedProcedure.query(async ({ ctx }) => {
    invariant(ctx.session?.user?.email, 'no user email');
    const subscription = await db
      .selectFrom('stripe.customer')
      .innerJoin(
        'stripe.subscription',
        'stripe.customer.id',
        'stripe.subscription.customer'
      )
      .selectAll()
      .where('stripe.customer.email', '=', ctx.session?.user?.email)
      .executeTakeFirst();

    return subscription;
  }),
  isSubdomainValid: protectedProcedure
    .input(z.object({ subdomain: z.string().min(1) }))
    .mutation(async ({ input }) => {
      if (isReservedSubdomain(input.subdomain)) {
        return { valid: false };
      }
      const collection = await prisma.collection.findUnique({
        where: {
          subdomain: input.subdomain,
        },
      });
      return { valid: !collection };
    }),
  createCheckoutSession: protectedProcedure
    .input(CreateCheckoutSessionValidator)
    .mutation(async ({ input, ctx }) => {
      invariant(ctx.session?.user?.email, 'missing user email');
      if (input.planName === 'lifetime') {
        const session = await stripe.checkout.sessions.create({
          line_items: [
            {
              price_data: {
                currency: 'usd',
                unit_amount: 150 * 100,
                product_data: {
                  name: 'Early Supporter',
                  description:
                    'Lifetime early supporter personal plan. Includes unlimited testimonials on unlimited websites, and personal support.',
                },
              },
              quantity: 1,
            },
          ],
          mode: 'payment',
          success_url:
            // env.SERVER_URL +
            `https://opentestimonials.com/dashboard/subscribed?session_id={CHECKOUT_SESSION_ID}`,
          //env.SERVER_URL +
          cancel_url: 'https://opentestimonials.com/dashboard/billing',
          customer_email: ctx.session?.user?.email,
        });
        invariant(session.url, 'missing session url');
        return { url: session.url };
      }
      const STRIPE_PRICE_DATA: Record<
        string,
        Stripe.Checkout.SessionCreateParams.LineItem.PriceData
      > = {
        personal: {
          currency: 'usd',
          unit_amount: 15 * 100,
          recurring: {
            interval: 'month',
          },
          product_data: {
            name: 'Starter',
            description: 'For small / medium sized businesses.',
          },
        },
        teams: {
          currency: 'usd',
          unit_amount: 299 * 100,
          recurring: {
            interval: 'month',
          },
          product_data: {
            name: 'Teams',
            description: 'For small / medium sized businesses.',
          },
        },
      };
      const session = await stripe.checkout.sessions.create({
        line_items: [
          {
            price_data: STRIPE_PRICE_DATA[input.planName],
            quantity: 1,
          },
        ],
        mode: 'subscription',
        success_url:
          env.SERVER_URL +
          `/dashboard/subscribed?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: env.SERVER_URL + '/dashboard/billing',
        customer_email: ctx.session?.user?.email,
      });
      invariant(session.url, 'missing session url');
      return { url: session.url };
    }),
});
