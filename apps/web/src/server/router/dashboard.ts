import { TRPCError } from '@trpc/server';
import { createRouter } from './context';
import { z } from 'zod';
import {
  CreateCollectionValidator,
  getAirtableParts,
} from '@/validators/collection';
import { prisma } from '@/server/db/client';
import { RESERVED_WORDS } from '@/lib/const';

function isReservedSubdomain(subdomain: string) {
  return RESERVED_WORDS.has(subdomain.toLowerCase());
}

export const dashboardRouter = createRouter()
  .query('hello', {
    resolve({ ctx }) {
      return 'world';
    },
  })
  .middleware(async ({ ctx, next }) => {
    // Any queries or mutations after this middleware will
    // raise an error unless there is a current session
    if (!ctx.session) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }
    return next();
  })
  .query('getSecretMessage', {
    async resolve({ ctx }) {
      return 'You are logged in and can see this secret message!';
    },
  })
  .query('collections', {
    async resolve({ ctx }) {
      return prisma.collection.findMany({
        where: {
          ownerId: ctx.session?.user?.id,
        },
      });
    },
  })
  .query('collection', {
    input: z.object({
      subdomain: z.string(),
    }),
    async resolve({ ctx, input }) {
      const collection = await prisma.collection.findUnique({
        where: {
          subdomain: input.subdomain,
        },
      });
      if (collection?.ownerId !== ctx.session?.user?.id) {
        throw new TRPCError({ code: 'UNAUTHORIZED' });
      }
      return collection;
    },
  })
  .mutation('collection', {
    input: CreateCollectionValidator,
    async resolve({ input }) {
      if (isReservedSubdomain(input.subdomain)) {
        throw new TRPCError({ code: 'FORBIDDEN' });
      }
      const { baseId, tableId } = getAirtableParts(input.airtableUrl);
      return prisma.collection.create({
        data: { ...input, airtableBase: baseId, airtableTable: tableId },
      });
    },
  })
  .mutation('isSubdomainValid', {
    input: z.object({ subdomain: z.string().min(1) }),
    async resolve({ input }) {
      if (isReservedSubdomain(input.subdomain)) {
        return { valid: false };
      }
      const collection = await prisma.collection.findUnique({
        where: {
          subdomain: input.subdomain,
        },
      });
      return { valid: !collection };
    },
  });
